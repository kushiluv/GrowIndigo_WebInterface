<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Leaflet Map</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.2/leaflet.draw.css"/>

</head>
<body>
    <div id="map"></div>
    <div id="data" data-value="{{ data }}"></div>

    <div id="filter-container">
        <form action="{{ url_for('filter_polygons') }}" method="post">
          <div class="mb-3">
            <label for="state-select" class="form-label">State:</label>
            <select id="state-select" name="state" class="form-select">
              <option value="All">All States</option>
              <!-- State options will be generated dynamically using JavaScript -->
            </select>
          </div>
      
          <div class="mb-3">
            <label for="district-select" class="form-label">District:</label>
            <select id="district-select" name="district" class="form-select">
              <option value="All">All Districts</option>
              <!-- District options will be generated dynamically based on the selected state using JavaScript -->
            </select>
          </div>
          <div class="mb-3">
            <label for="mdo-select" class="form-label">MDO ID:</label>
            <select id="mdo-select" name="mdo_id" class="form-select">
                <option value="All">All MDO IDs</option>
                <!-- MDO ID options will be generated dynamically using JavaScript -->
            </select>
        </div>
          <div class="mb-3">
            <button type="submit" class="btn btn-primary">Filter</button>
          </div>
          <div class="row">
            <div class="col">
              <div class="card">
                <div class="card-header" id="invalid-polygons-list-heading">
                  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#invalid-polygons-list-collapse" aria-expanded="true" aria-controls="invalid-polygons-list-collapse">
                    Polygons not yet validated :
                  </button>
                </div>
                <div id="invalid-polygons-list-collapse" class="collapse show" aria-labelledby="invalid-polygons-list-heading">
                  <div class="card-body" style="background-color: white;">
                    <ul id="invalid-polygons-list"></ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="row">
            <div class="col">
              <div class="card">
                <div class="card-header" id="polygons-list-heading">
                  <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#polygons-list-collapse" aria-expanded="true" aria-controls="polygons-list-collapse">
                    Change visibility of Polygons:
                  </button>
                </div>
                <div id="polygons-list-collapse" class="collapse show" aria-labelledby="polygons-list-heading">
                  <div class="card-body" style="background-color: white;">
                    <ul id="polygons-List"></ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
        </form>
      </div>
    
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        
        // Initialize the Leaflet map
        
        var map = L.map('map', {
                zoomControl: false // Disable the default zoom control
                }).setView([{{ center_lat }}, {{ center_lng }}], {{ zoom }});
            // Create a feature group to store the drawn items
            // Create a feature group to store the drawn items
var drawnItems = new L.FeatureGroup();

// Add the feature group to the map
map.addLayer(drawnItems);

// ...

// Add the leaflet.draw plugin to the map
var drawControl = new L.Control.Draw({
  edit: {
    featureGroup: drawnItems,
    edit: {},
    remove: {
      skipMiddleMarkers: true
    }
  }
});


            L.control.zoom({
                         position: 'topright'
                        }).addTo(map);
        // Add the tile layer to the map
        // Define the satellite tile layer
                var satelliteTileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Imagery © <a href="https://www.arcgis.com/">ArcGIS</a>'
                });

                // Define the street tile layer
                var streetTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
                    maxZoom: 18
                });

                // Define a base layer group to switch between tile layers
                var baseLayers = {
                    "Satellite View": satelliteTileLayer,
                    "Map View": streetTileLayer
                };

                // Set the satellite tile layer as the default layer
                satelliteTileLayer.addTo(map);

                // Add the base layer control to the map
                L.control.layers(baseLayers).addTo(map);

        // Retrieve the data from the HTML data attribute
        var dataElement = document.getElementById('data');
        var data = JSON.parse(dataElement.getAttribute('data-value'));

        // Retrieve the filter selects
var stateSelect = document.getElementById('state-select');
var districtSelect = document.getElementById('district-select');
var mdoIdSelect = document.getElementById('mdo-select');

// Initialize the district and MDO_ID options based on the selected state
stateSelect.addEventListener('change', function() {
    var selectedState = stateSelect.value;
    initializeDistrictOptions(selectedState);
});

// Initialize the district and MDO_ID options on page load
initializeDistrictOptions(stateSelect.value);

// Function to initialize the district and MDO_ID options based on the selected state
function initializeDistrictOptions(selectedState) {
    // Retrieve the unique districts based on the selected state
    var districts = getUniqueDistricts(selectedState);

    // Clear the existing district options
    while (districtSelect.options.length > 0) {
        districtSelect.options.remove(0);
    }

    // Add the "All Districts" option
    var allDistrictOption = document.createElement('option');
    allDistrictOption.value = 'All';
    allDistrictOption.text = 'All Districts';
    districtSelect.appendChild(allDistrictOption);

    // Add the district options
    districts.forEach(function (district) {
        var option = document.createElement('option');
        option.value = district;
        option.text = district;
        districtSelect.appendChild(option);
    });

    // Retrieve the unique MDO_IDs based on the selected state and district
    var mdoIds = getUniqueMdoIds(selectedState, districtSelect.value);

    // Clear the existing MDO_ID options
    while (mdoIdSelect.options.length > 0) {
        mdoIdSelect.options.remove(0);
    }

    // Add the "All MDO IDs" option
    var allMdoIdOption = document.createElement('option');
    allMdoIdOption.value = 'All';
    allMdoIdOption.text = 'All MDO IDs';
    mdoIdSelect.appendChild(allMdoIdOption);

    // Add the MDO_ID options
    mdoIds.forEach(function (mdoId) {
        var option = document.createElement('option');
        option.value = mdoId;
        option.text = mdoId;
        mdoIdSelect.appendChild(option);
    });
}

// Retrieve the unique states from the data
var states = getUniqueStates();

// Add the state options
states.forEach(function (state) {
    var option = document.createElement('option');
    option.value = state;
    option.text = state;
    stateSelect.appendChild(option);
});

// Function to retrieve the unique states from the data
function getUniqueStates() {
    var states = [];

    data.forEach(function (entry) {
        if (!states.includes(entry.State)) {
            states.push(entry.State);
        }
    });

    return states;
}

// Function to retrieve the unique districts based on the selected state
function getUniqueDistricts(selectedState) {
    var districts = [];

    data.forEach(function (entry) {
        if (selectedState === 'All' || entry.State === selectedState) {
            if (!districts.includes(entry.District)) {
                districts.push(entry.District);
            }
        }
    });

    return districts;
}

// Function to retrieve the unique MDO_IDs based on the selected state and district
function getUniqueMdoIds(selectedState, selectedDistrict) {
    var mdoIds = [];

    data.forEach(function (entry) {
        if ((selectedState === 'All' || entry.State === selectedState) &&
            (selectedDistrict === 'All' || entry.District === selectedDistrict)) {
            if (!mdoIds.includes(entry.MDO_ID)) {
                mdoIds.push(entry.MDO_ID);
            }
        }
    });

    return mdoIds;
}
function savePolygonValidation(farmerId, fieldId, mdoId) {
    // Retrieve the selected validation option
    var validationSelect = document.getElementById('validation-select');
    var validation = validationSelect.value;

    // Send an AJAX request to the server to save the polygon validation
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/save_validation', true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var response = JSON.parse(xhr.responseText);
            if (response.status === 'success') {
                // Create prompt elements
                var promptDiv = document.createElement('div');
                var promptMessage = document.createElement('p');
                promptMessage.innerText = 'Polygon validation saved successfully.';

                // Add Bootstrap classes to the prompt elements
                promptDiv.classList.add('alert', 'alert-success', 'position-absolute', 'top-50', 'start-50', 'translate-middle');
                promptDiv.style.zIndex = 1000; // Set a high z-index value to make it appear above all layers
                promptMessage.classList.add('m-0'); // Add margin class to remove any unnecessary space

                // Append the prompt elements to the document body
                promptDiv.appendChild(promptMessage);
                document.body.appendChild(promptDiv);

                // Hide the prompt after 1 second
                setTimeout(function() {
                    document.body.removeChild(promptDiv);
                }, 1000);
            } else {
                console.error('Failed to save polygon validation.');
            }
        }
    };
    xhr.send('farmer_id=' + farmerId + '&field_id=' + fieldId + '&mdo_id=' + mdoId + '&validation=' + validation);
}


// Function to send the updated coordinates to the server

function saveCoordinates(updatedCoordinates, entry) {
    // Retrieve the farmer ID and field ID from the entry object
    var farmerId = entry.Farmer_ID;
    var fieldId = entry['Field ID'];

    // Create a JSON payload with the updated coordinates
    var payload = {
        coordinates: updatedCoordinates,
        farmer_id: farmerId,
        field_id: fieldId
    };

    // Send an AJAX request to the server to save the updated coordinates
    var xhr = new XMLHttpRequest();
    xhr.open('POST', '/save_coordinates', true);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
            if (xhr.status === 200) {
                var response = JSON.parse(xhr.responseText);
                if (response.status === 'success') {
                    // Create prompt elements
                    var promptDiv = document.createElement('div');
                    var promptMessage = document.createElement('p');
                    promptMessage.innerText = response.prompt;

                    // Add Bootstrap classes to the prompt elements
                    promptDiv.classList.add('alert', 'alert-primary', 'position-absolute', 'top-50', 'start-50', 'translate-middle');
                    promptDiv.style.zIndex = 1000; // Set a high z-index value to make it appear above all layers
                    promptMessage.classList.add('m-0'); // Add margin class to remove any unnecessary space

                    // Append the prompt elements to the document body
                    promptDiv.appendChild(promptMessage);
                    document.body.appendChild(promptDiv);

                    // Hide the prompt after 1 second
                    setTimeout(function() {
                        document.body.removeChild(promptDiv);
                    }, 1000);
                } else {
                    console.error('Failed to save coordinates.');
                }
            } else {
                console.error('Error occurred while saving coordinates. Status: ' + xhr.status);
            }
        }
    };
    xhr.send(JSON.stringify(payload));
}

var polygonsList = document.getElementById('polygons-List');
var invalidPolygonsList = document.getElementById('invalid-polygons-list');
        // Iterate over the data and create polylines on the map
        if (data) {
    data.forEach(function(entry) {
        var points = entry.Points.map(function(point) {
            return [point.Latitude, point.Longitude];
        });

        if (entry.polygon_validation !== 'Good Polygon' && entry.polygon_validation !== 'Bad but fixable' && entry.polygon_validation !== 'Bad not fixable') {
                    // Create a list item for the invalid polygon
                    var listItem = document.createElement('li');
                    
                    // Create a hyperlink to the polygon center with zoom
                    var hyperlink = document.createElement('a');
                    hyperlink.href = '#';
                    hyperlink.textContent = 'Field ID: ' + entry['Field ID'] + ', Farmer ID: ' + entry.Farmer_ID;
                    hyperlink.addEventListener('click', function(event) {
                        event.preventDefault();
                        map.setView(polygon.getBounds().getCenter(), 15);
                    });

                    // Append the hyperlink to the list item
                    listItem.appendChild(hyperlink);

                    // Append the list item to the invalid polygons list
                    invalidPolygonsList.appendChild(listItem);
                }
        var fillColor = 'transparent';
        var outlineColor = 'red';

        // Check the polygon validation value and update the fill and outline colors accordingly
        if (entry.polygon_validation === 'Good Polygon') {
            fillColor = 'green';
            outlineColor = 'darkgreen';
        } else if (entry.polygon_validation === 'Bad but fixable') {
            fillColor = 'yellow';
            outlineColor = 'darkgoldenrod';
        } else if (entry.polygon_validation === 'Bad not fixable') {
            fillColor = 'red';
            outlineColor = 'darkred';
        }

        var polygon = L.polygon(points, { color: outlineColor, fillColor: fillColor, fillOpacity: 0.4, editable: true }).addTo(drawnItems);


        // Customize the editing icon

        // Add any other necessary properties to the polygon
        polygon.properties = {
            state: entry.State,
            district: entry.District,
            farmerId: entry.Farmer_ID,
            fieldId: entry['Field ID'],
            mdoId: entry.MDO_ID,
        };

        
      

// Append the buttons to the popup content
        var popupContentElement = document.createElement('div');
        popupContentElement.innerHTML = `
            <div>
                <p><strong>State:</strong> ${entry.State}</p>
                <p><strong>District:</strong> ${entry.District}</p>
                <p><strong>Farmer ID:</strong> ${entry.Farmer_ID}</p>
                <p><strong>Field ID:</strong> ${entry['Field ID']}</p>
                <p><strong>MDO ID:</strong> ${entry.MDO_ID}</p>
                <div class="form-group">
                    <label for="validation-select">Polygon Validation:</label>
                    <select id="validation-select" class="form-control">
                        <option value="Good Polygon">Good Polygon</option>
                        <option value="Bad but fixable">Bad but fixable</option>
                        <option value="Bad not fixable">Bad not fixable</option>
                    </select>
                </div>
                <div class="button-group">
                    <button class="btn btn-primary" onclick="savePolygonValidation('${entry.Farmer_ID}', '${entry['Field ID']}', '${entry.MDO_ID}')">Save</button>
                    <div id="new-vertices-buttons">
                        <!-- Buttons will be appended here -->
                    </div>
                </div>
            </div>
        `;
            // Create a list item for the polygon with checkbox
        var listItem = document.createElement('li');

        // Create a checkbox for the polygon
        var checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true; // Checkbox is checked by default
        checkbox.addEventListener('change', function() {
            if (this.checked) {
                // Show the polygon
                polygon.addTo(drawnItems);
            } else {
                // Hide the polygon
                drawnItems.removeLayer(polygon);
            }
        });

        // Create a label for the checkbox with field and farmer IDs
        var label = document.createElement('label');
        label.textContent = 'Field ID: ' + entry['Field ID'] + ', Farmer ID: ' + entry.Farmer_ID;
        label.insertBefore(checkbox, label.firstChild);

        // Append the label to the list item
        listItem.appendChild(label);

        // Append the list item to the polygons list
        polygonsList.appendChild(listItem);
        // Create the "Save New Vertices" button
        var saveButton = document.createElement('button');
        saveButton.innerHTML = 'Save New Vertices';
        saveButton.classList.add('btn', 'btn-primary');
        saveButton.onclick = function() {
            saveCoordinates(polygon.getLatLngs()[0], entry);
        };
        popupContentElement.querySelector('#new-vertices-buttons').appendChild(saveButton);

      
      

        // Attach the popup to the polygon
        polygon.bindPopup(popupContentElement);

        // Attach event listeners to the polygon
        polygon.on('click', function(e) {
            // Access the properties of the clicked polygon
            var properties = e.target.properties;
            console.log('State:', properties.state);
            console.log('District:', properties.district);
            // Handle other actions as needed
        });

      

       

        
    });
} else {
    console.error('No data found.');
}    
    </script> 
</body>
</html>